		struct GenHeadInfoDefine
		{
			wstring    property;
			wstring    value;
		};
		
		class GenTokenDefine
		{
			enum TokenOptional
			{
				False,
				True,
			};
			wstring			name;
			wstring			regex;
			TokenOptional	ignore;
		};

	
		class GenTypeObject
		{

		};

		class GenArrayTypeObject :  GenTypeObject
		{
			GenTypeObject			element;
		};
	
		class GenStringTypeObject :  GenTypeObject
		{

		};
		class GenNormalTypeObject :  GenTypeObject
		{
			wstring									name;
		};
		class GenSubTypeObject :  GenTypeObject
		{
			GenTypeObject						parent;
			wstring									name;
		};
		
		class GenTypeDefine
		{

		};
		class GenClassTypeDefine :  GenTypeDefine
		{
			GenTypeDefine[]				subTypes;
			GenClassMemberTypeDefine[]	members;
			GenTypeObject				parent;
			wstring						name;
		};
		class GenEnumTypeDefine :  GenTypeDefine
		{
			GenEnumMemberTypeDefine[]			members;
			wstring								name;
		};
		class GenClassMemberTypeDefine :  GenTypeDefine
		{
			GenTypeObject						   type;
			wstring									name;
		};
		class GenEnumMemberTypeDefine :  GenTypeDefine
		{
			wstring									name;
		};
		class GenGrammarTypeDefine 
		{

		};
		class GenGrammarTextTypeDefine :  GenGrammarTypeDefine
		{
			wstring												text;
		};
		class GenGrammarNormalTypeDefine :  GenGrammarTypeDefine
		{
			wstring												name;
		};
		class GenGrammarSequenceTypeDefine :  GenGrammarTypeDefine
		{
			GenGrammarTypeDefine				first;
			GenGrammarTypeDefine				second;
		};
		class GenGrammarLoopTypeDefine :  GenGrammarTypeDefine
		{
			GenGrammarTypeDefine				grammar;
		};
		class GenGrammarOptionalTypeDefine :  GenGrammarTypeDefine
		{
			GenGrammarTypeDefine				grammar;
		};
		class GenGrammarAssignTypeDefine :  GenGrammarTypeDefine
		{
			wstring									name;
			GenGrammarTypeDefine				grammar;
		};
		
		class GenGrammarSetterTypeDefine :  GenGrammarTypeDefine
		{
			GrammarDef grammar;
			wstring												name;
			wstring												value;
		};
		class GenGrammarAdditionTypeDefine :  GenGrammarTypeDefine
		{
			GenGrammarTypeDefine				grammar;
			GenGrammarSetterTypeDefine[]		setters;
		};
		class GenGrammarUsingTypeDefine :  GenGrammarTypeDefine
		{
			GenGrammarTypeDefine				grammar;
		};
		class GenGrammarCreateTypeDefine :  GenGrammarTypeDefine
		{
			GenTypeObject						type;
			GenGrammarTypeDefine				grammar;
		};
		
		class GenGrammarAlternationTypeDefine : GenGrammarTypeDefine
		{
			GenGrammarTypeDefine left;
			GenGrammarTypeDefine right;
		}
		class GenRuleDefine
		{
			GenTypeObject						type;
			wstring								name;
			GenGrammarTypeDefine[]				grammars;
		};
		class GenTableDefine
		{
			GenHeadInfoDefine[] heads;
			GenTypeDefine[]   types;
			GenTokenDefine[]  tokens;
			GenRuleDefine[]   rules;
		};
		
token CLASS = "class";
token STRUCT = "struct";
token ENUM = "enum";
token TOKEN = "token";
token DISCARDTOKEN = "ignoretoken";
token RULE = "rule";
token AS = "as";
token WITH = "with";
token OPEN = "{";
token CLOSE = "}";
token SEMICOLON = ";";
token COLON = ":";
token COMMA = ",";
token DOT = ".";
token ASSIGN = "=";
token USING = "!";
token OR = "|";
token OPTOPEN = "/[";
token OPTCLOSE = "/]";
token PREOPEN = "/(";
token PRECLOSE = "/)";
token NAME = "[a-zA-Z_]/w*";
token STRING = "\"(\\\"|[^"])*\""
ignoretoken SPACE = "/s+";
ignoretoken LINENOTE = "//[^\n]*\n";
ignoretoken BLOCKNOTE = "/*.*?*/";

rule GenTypeObject Type
        = NAME : name as GenNormalTypeObject
        = "token" as GenTokenTypeObject
        = Type : parent "." NAME : name as GenSubTypeObject 
        = Type : element "[" "]" as GenArrayTypeObject
        ;
rule GenEnumMemberTypeDefine EnumMember
        = NAME : name "," as GenEnumMemberTypeDefine 
        ;
rule GenEnumTypeDefine Enum
        = "enum" NAME : name  "{" { EnumMember : members } "}" as GenEnumTypeDefine
        ;
rule GenClassMemberTypeObject ClassMember
        = Type : type NAME : name ";" as GenClassMemberTypeObject
        ;
rule GenTypeDefine TypeDecl
        = !Enum | !Class
        ;

rule GenClassTypeDefine Class
        = ("struct" |"class") NAME : name [ ":" Type : parent ] "{" { ClassMember : members | TypeDecl : subTypes } "}" ";" as GenClassTypeDefine
        ;
		
rule GenGrammarTypeDefine SequenceGrammar
        = !PrimitiveGrammar
        = SequenceGrammar : first PrimitiveGrammar : second as GenGrammarSequenceTypeDefine
        ;
rule GenGrammarTypeDefine AlternativeGrammar
        = !SequenceGrammar
        = AlternativeGrammar : left "|" SequenceGrammar : right as GenGrammarAlternationTypeDefine
        ;
		
rule GenGrammarTypeDefine SetterGrammar
        = NAME : name "=" STRING : value  as GenGrammarSetterTypeDefine
rule GenGrammarTypeDefine Grammar
        = !AlternativeGrammar
        = Grammar : grammar "as" Type : type as GenGrammarCreateTypeDefine
        =!SetterGrammar
        ;


rule GenGrammarTypeDefine PrimitiveGrammar
        = NAME : name as GenGrammarNormalTypeDefine
        = STRING : text as GenGrammarTextTypeDefine
        = PrimitiveGrammar : grammar ":" NAME : name as GenGrammarAssignTypeDefine
        = "!" PrimitiveGrammar : grammar as GenGrammarUsingTypeDefine
        = "[" Grammar : grammar "]" as GenGrammarOptionalTypeDefine
        = "{" Grammar : grammar "}" as GenGrammarLoopTypeDefine
        = "(" !Grammar ")"
        ;

rule GenTokenDefine TokenDecl
        = "token" NAME : name "=" STRING : regex ";" as GenTokenDefine with { ignore = "False" }
        = "ignoretoken" NAME : name "=" STRING : regex ";" as GenTokenDefine with { ignore = "True" }
        ;
rule GenHeadInfoDefine HeadDecl = NAME : property ":" STRING : value ";" as GenHeadInfoDefine;
rule GenRuleDefine RuleDecl
        = "rule" Type : type NAME : name { "=" Grammar : grammars } ";" as GenRuleDefine
        ;
rule GenTableDefine ParserDecl
        = {HeadDecl : heads}| { TypeDecl : definitions} |{ TokenDecl : definitions} |{ RuleDecl : definitions } as GenTableDefine
        ;
