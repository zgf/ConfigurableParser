1.感觉ParserSymbol可以只提供Map不用提供List; 已解决
2.ParserSymbol GetTypeToWString() 已解决.
3.//生成路径验证
//对于非数组的成员,多次赋值给警告.
//对于没有对Node所有成员赋值的,给出警告
4//一条文法可能有几个合法的创建节点 该问题貌似没处理
//token regex symbol之间的缓存不需要distoken.
//distoken添加单独的distokenName->symbol映射
//查找开始文法节点
//构建有向图自动机
//合并同路径

1.缺少头信息文法验证 已添加
//classprefix只能有一个
//namspace不能同名
//include不能重复
2.缺少头信息相关文法 已添加
3.根据头信息对语法树进行修改. classprefix要修改语法树上的className等等 等待解决.目前不想添加- -

3.5工作:
使生成的lexer文件正常,研究后面的反射怎么写- -....
终于想通了,不用煞笔的类型转来转去,分散在自动机内的方法了.
直接准备一个同构的通用语法树.
自动机运行后生成的是通用语法树
大概是 Name:类名
FieldMap: Key:字段名 Value:赋值给它的节点在节点池的index
TermMap: Key:字段名 Value:对应的终结符号在词法流的index.
class TreeNode
{
	wstring Name;
	unordered_map<wstring, int> FieldMap;
	unordered_map<wstring, int> TermMap;
};

LALR运行后得到的是这样一个通用的Tree
然后可以遍历Tree,用反射获得异构型Tree.
之后遍历异构Tree.生成手写语法树的文本.到生成文件去.
以XML解析为例
这样在生成的解析器文件内,就获得了XML的EBNF的结构化表示
然后丢进解析器,生成LALR,输入XML文件,生成通用的Tree
生成的文件再编译时已经加载了XML的节点定义.
并且还生成了遍历和反射异构型树的函数.
对通用Tree遍历,生成异构树,就拿到了对XML解析的AST.
Good Job:)
这两天复习资料准备面试...工程暂停
需要LALR(2)文法的解析器..或者造个带回溯的解析器.不然无法解析这个扩展的EBNF
现在的写法不支持同名class作为create的节点名.因为没有编码作用域信息进去.  
token类问题已解决.
lexer 添加成功.
调整jumptable 解决
编写通用解析器 解决
构造通用语法树 解决
编写回溯解析器 解决
二义性是文法设计的锅,
修改二义性文法 解决
构造反射用函数 解决
构造核心EBNF函数 解决
Lexer改为非生成文件 解决
构造异构AST生成函数 解决
class的绝对名称避免重名 
重构GeneralFile.生成解析器文件 解决
写个shell.点击直接codegen.
重写词法分析 解决
EBNF Core源码中使用"\n\"的问题 解决
写\n词法分析时候会当做'\n' 解决
捕获的String外面有""需要去掉 解决
源码中写regex时候,""内部的所有"需要添加转义为\"; 解决
终于看到完工的曙光了- -
砍掉parser中的函数内静态变量 解决

headinfo里面的classprefix待解决
生成文件应该放到GenerateFile文件里面去 解决
添加dirname HeadInfo. 解决
添加path HeadInfo 解决
编写XML的解析
重构上一版正则引擎,解决掉NFA的Capture性能过渣的问题.或者编写完
ExRegex的解析,添加上对平衡组的支持,替换掉原先的正则核心.
添加错误恢复机制.比较麻烦的是错在A挂在B- -还要研究下怎么做比较好.
把通用语法树重新组织.二义性分析歧义限制在局部范围,而不是扩展出多颗语法树,扩展出多颗是很low很渣的做法.
XML解析器有问题 待解决
根据Path指定的路径调整Include.用boost filesystem

根据dirname 调整Include路径
赶紧补上单元测试-.-........添加更多的断言

