1.感觉ParserSymbol可以只提供Map不用提供List; 已解决
2.ParserSymbol GetTypeToWString() 已解决.
3.//生成路径验证
//对于非数组的成员,多次赋值给警告.
//对于没有对Node所有成员赋值的,给出警告
4//一条文法可能有几个合法的创建节点 该问题貌似没处理
//token regex symbol之间的缓存不需要distoken.
//distoken添加单独的distokenName->symbol映射
//查找开始文法节点
//构建有向图自动机
//合并同路径

1.缺少头信息文法验证 已添加
//classprefix只能有一个
//namspace不能同名
//include不能重复
2.缺少头信息相关文法 已添加
3.根据头信息对语法树进行修改. classprefix要修改语法树上的className等等 等待解决.目前不想添加- -

3.5工作:
使生成的lexer文件正常,研究后面的反射怎么写- -....
终于想通了,不用煞笔的类型转来转去,分散在自动机内的方法了.
直接准备一个同构的通用语法树.
自动机运行后生成的是通用语法树
大概是 Name:类名
FieldMap: Key:字段名 Value:赋值给它的节点在节点池的index
TermMap: Key:字段名 Value:对应的终结符号在词法流的index.
class TreeNode
{
	wstring Name;
	unordered_map<wstring, int> FieldMap;
	unordered_map<wstring, int> TermMap;
};

LALR运行后得到的是这样一个通用的Tree
然后可以遍历Tree,用反射获得异构型Tree.
之后遍历异构Tree.生成手写语法树的文本.到生成文件去.
以XML解析为例
这样在生成的解析器文件内,就获得了XML的EBNF的结构化表示
然后丢进解析器,生成LALR,输入XML文件,生成通用的Tree
生成的文件再编译时已经加载了XML的节点定义.
并且还生成了遍历和反射异构型树的函数.
对通用Tree遍历,生成异构树,就拿到了对XML解析的AST.
Good Job:)
这两天复习资料准备面试...工程暂停
需要LALR(2)文法的解析器..或者造个带回溯的解析器.不然无法解析这个扩展的EBNF
现在的写法不支持同名class作为create的节点名.因为没有编码作用域信息进去.  
token类问题已解决.
lexer 添加成功.
调整jumptable 解决
编写通用解析器 解决
构造通用语法树 解决
编写回溯解析器 解决
二义性是文法设计的锅,
修改二义性文法 解决
构造反射用函数 解决
输出到文件 
构造核心EBNF函数 解决
Lexer改为非生成文件 
构造异构AST生成函数 解决
class的绝对名称避免重名 
重构GeneralFile.生成解析器文件
终于看到完工的曙光了- -